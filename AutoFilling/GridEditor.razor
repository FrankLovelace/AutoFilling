@namespace AutoFilling

<div class="panel-controles">
    <div class="control-grupo">
        <label>Filas: <strong>@Filas</strong></label>
        <button class="btn" @onclick="() => CambiarDimensiones(1, 0)">+</button>
        <button class="btn" @onclick="() => CambiarDimensiones(-1, 0)">-</button>
    </div>

    <div class="control-grupo">
        <label>Columnas: <strong>@Columnas</strong></label>
        <button class="btn" @onclick="() => CambiarDimensiones(0, 1)">+</button>
        <button class="btn" @onclick="() => CambiarDimensiones(0, -1)">-</button>
    </div>
    
    <div class="instrucciones">
        @if (inicioSeleccion == null)
        {
            <span>Haz clic para iniciar un rect√°ngulo</span>
        }
        else
        {
            <span class="esperando">Haz clic en otro punto para cerrar</span>
            <button class="btn-cancelar" @onclick="CancelarSeleccion">Cancelar</button>
        }
    </div>
</div>

<!-- GRID VISUAL -->
<div class="grid-contenedor" 
     style="grid-template-columns: repeat(@Columnas, 40px); 
            grid-template-rows: repeat(@Filas, 40px);">
            
    @for (int r = 0; r < Filas; r++)
    {
        @for (int c = 0; c < Columnas; c++)
        {
            int fila = r; int col = c;
            var celda = Matriz[fila, col];
            
            <div class="casilla @ObtenerClase(celda, fila, col)" 
                 @onclick="() => AlClickarCasilla(fila, col)">
                 
                @if (celda.Ocupado)
                {
                    <span class="numero">@celda.Valor</span>
                }
            </div>
        }
    }
</div>

<style>
    .panel-controles { margin-bottom: 15px; display: flex; gap: 15px; align-items: center; background: #eee; padding: 10px; border-radius: 5px;}
    .btn { padding: 2px 10px; cursor: pointer; }
    .btn-cancelar { margin-left: 10px; background: #ffcccc; border: 1px solid red; }
    .instrucciones { margin-left: auto; font-size: 0.9em; color: #555; }
    .esperando { color: blue; font-weight: bold; }

    .grid-contenedor {
        display: grid;
        gap: 1px;
        background-color: #ccc;
        border: 1px solid #999;
        width: fit-content;
        user-select: none;
    }

    .casilla {
        background-color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-family: monospace;
        font-size: 1.2em;
    }

    .casilla:hover { background-color: #f0f0f0; }
    .seleccionando { background-color: #b3d9ff !important; }
    .ocupada { background-color: #fff; color: black; font-weight: bold; }
</style>

@code {
    public class Celda
    {
        public int Valor { get; set; } 
        public bool Ocupado { get; set; } = false;
        public Guid? RectanguloId { get; set; }
    }

    public class Rectangulo
    {
        public Guid Id { get; set; } = Guid.NewGuid();
        public int FilaInicio { get; set; }
        public int FilaFin { get; set; }
        public int ColInicio { get; set; }
        public int ColFin { get; set; }
    }

    public int Filas { get; set; } = 5;
    public int Columnas { get; set; } = 10;
    public Celda[,] Matriz { get; set; } = new Celda[0,0];
    private List<Rectangulo> RectangulosActivos = new();
    private (int r, int c)? inicioSeleccion = null;

    protected override void OnInitialized()
    {
        ReconstruirMatriz();
    }

    void AlClickarCasilla(int fila, int col)
    {
        if (Matriz[fila, col].Ocupado) return;

        if (inicioSeleccion == null)
        {
            inicioSeleccion = (fila, col);
        }
        else
        {
            var inicio = inicioSeleccion.Value;
            IntentarCrearRectangulo(inicio.r, inicio.c, fila, col);
            inicioSeleccion = null;
        }
    }

    void IntentarCrearRectangulo(int r1, int c1, int r2, int c2)
    {
        int rMin = Math.Min(r1, r2);
        int rMax = Math.Max(r1, r2);
        int cMin = Math.Min(c1, c2);
        int cMax = Math.Max(c1, c2);

        for (int r = rMin; r <= rMax; r++)
        {
            for (int c = cMin; c <= cMax; c++)
            {
                if (Matriz[r, c].Ocupado) return;
            }
        }

        var nuevoRect = new Rectangulo 
        { 
            FilaInicio = rMin, FilaFin = rMax, 
            ColInicio = cMin, ColFin = cMax 
        };
        RectangulosActivos.Add(nuevoRect);

        ReconstruirMatriz();
    }

    void ReconstruirMatriz()
    {
        Matriz = new Celda[Filas, Columnas];
        for (int i = 0; i < Filas; i++)
            for (int j = 0; j < Columnas; j++)
                Matriz[i, j] = new Celda();

        foreach (var rect in RectangulosActivos)
        {
            AplicarRectanguloBase(rect);
        }

        AplicarInteracciones();
    }

    void AplicarRectanguloBase(Rectangulo rect)
    {
        for (int r = rect.FilaInicio; r <= rect.FilaFin; r++)
        {
            for (int c = rect.ColInicio; c <= rect.ColFin; c++)
            {
                var celda = Matriz[r, c];
                celda.Ocupado = true;
                celda.RectanguloId = rect.Id;

                bool esBordeY = (r == rect.FilaInicio || r == rect.FilaFin);
                bool esBordeX = (c == rect.ColInicio || c == rect.ColFin);

                if (esBordeY && esBordeX) celda.Valor = 2; // Esquina Base
                else if (esBordeY || esBordeX) celda.Valor = 1; // Borde Base
                else celda.Valor = 0; // Centro
            }
        }
    }

    void AplicarInteracciones()
    {
        for (int r = 0; r < Filas; r++)
        {
            for (int c = 0; c < Columnas; c++)
            {
                var celda = Matriz[r, c];
                if (!celda.Ocupado || celda.Valor == 0) continue;

                if (TieneVecinoConflictivo(r, c, -1, 0, celda) || 
                    TieneVecinoConflictivo(r, c, 1, 0, celda) ||  
                    TieneVecinoConflictivo(r, c, 0, -1, celda) || 
                    TieneVecinoConflictivo(r, c, 0, 1, celda))    
                {
                    if (celda.Valor == 1) celda.Valor = 4;
                    
                    if (celda.Valor == 2) celda.Valor = 3;
                }
            }
        }
    }

    bool TieneVecinoConflictivo(int r, int c, int dr, int dc, Celda miCelda)
    {
        int nr = r + dr;
        int nc = c + dc;

        if (nr < 0 || nr >= Filas || nc < 0 || nc >= Columnas) return false;

        var vecino = Matriz[nr, nc];

        
        if (!vecino.Ocupado) return false;
        if (vecino.RectanguloId == miCelda.RectanguloId) return false;

        bool soyBorde = (miCelda.Valor == 1 || miCelda.Valor == 4);
        bool vecinoEsBorde = (vecino.Valor == 1 || vecino.Valor == 4);
        
        bool soyEsquina = (miCelda.Valor == 2 || miCelda.Valor == 3);
        bool vecinoEsEsquina = (vecino.Valor == 2 || vecino.Valor == 3);

        if (soyBorde && vecinoEsBorde) return true;
        if (soyEsquina && vecinoEsEsquina) return true;

        return false;
    }

    void CambiarDimensiones(int deltaFila, int deltaCol)
    {
        if (Filas + deltaFila < 1 || Columnas + deltaCol < 1) return;
        Filas += deltaFila;
        Columnas += deltaCol;
        
        RectangulosActivos.RemoveAll(rect => rect.FilaFin >= Filas || rect.ColFin >= Columnas);
        ReconstruirMatriz();
    }

    void CancelarSeleccion() => inicioSeleccion = null;

    string ObtenerClase(Celda celda, int r, int c)
    {
        if (celda.Ocupado) return "ocupada";
        if (inicioSeleccion != null && inicioSeleccion.Value.r == r && inicioSeleccion.Value.c == c) return "seleccionando";
        return "";
    }
}